# Simplest possible VWF applcation.
# See https://virtual.wf/getting_started.html for more information.
---
extends: http://vwf.example.com/scene.vwf
methods:
  initializeCamera:
  update:
  sendChat:
    parameters:
      - player
      - message
properties:
  usersSharedView: false
scripts:
  - |
    var rotate = new Boolean();
    this.initialize = function(){
      this.future(0).initializeCamera();
      this.future(0).update();
    }
    this.initializeCamera = function() {
      this.camera.translation = [250, -600, 150];
      //this.camera.rotation = [1, 0, 0, -10];
      this.camera.lookAt = this.children['ball'].id;
    }

    this.update = function() {
      this.ball.move();
      if(rotate == true)
      {
        console.log(this.camera.rotation[0]);
        this.camera.rotateBy([1, 0, 0, 0.2], 0);

      }
      this.future(1.0/60.0).update(); //schedule the next step

    }
    this.pointerClick = function(){
      console.log("click");
      if(rotate == true){rotate = false;}
      else{rotate = true;}

    }
children:
  board:
    extends: http://vwf.example.com/node3.vwf
    source: board.dae

  playerOne:
    extends: http://vwf.example.com/node3.vwf
    source: paddle.dae
    properties:
      xPos: -220
      translation: [-470, 0, 0]

  playerTwo:
    extends: http://vwf.example.com/node3.vwf
    source: paddle.dae
    properties:
      xPos: 231

  ball:
    extends: http://vwf.example.com/node3.vwf
    source: ball.dae
    properties:
      xSpeed: 2
      ySpeed: 5
    methods:
      move:
      dealWithPaddleBounce:
    children:
      ballMaterial:
        extends: http://vwf.example.com/material.vwf
        properties:
          color: "#0000ff"
    scripts:
      - |
        this.move = function() {
                var newTrans = [
                  this.translation[ 0 ] + this.xSpeed,
                  this.translation[ 1 ] + this.ySpeed,
                  this.translation[ 2 ]
                ];

                // Did we hit a wall?
                var maxY = 145;
                var minY = -maxY;
                if ( newTrans[ 1 ] >= maxY ) {
                  newTrans[ 1 ] = maxY;
                  this.ySpeed = -this.ySpeed;
                } else if ( newTrans[ 1 ] <= minY ) {
                  newTrans[ 1 ] = minY;
                  this.ySpeed = -this.ySpeed;
                }

                // Did we hit a paddle?
                var ballAtRightSide = ( newTrans[ 0 ] >= this.parent.playerTwo.xPos );
                var ballAtLeftSide = ( newTrans[ 0 ] <= this.parent.playerOne.xPos );
                if ( ballAtRightSide ) {
                  this.dealWithPaddleBounce( this.parent.playerTwo, newTrans );
                } else if ( ballAtLeftSide ) {
                  this.dealWithPaddleBounce( this.parent.playerOne, newTrans );
                } else {
                  this.translation = newTrans;
                }
              };
              this.dealWithPaddleBounce = function( paddle, translation ) {
                var yPos = paddle.translation[ 1 ];
                var paddleExtent = 36;
                if ( translation[ 1 ] > ( yPos + paddleExtent ) || translation[ 1 ] < ( yPos - paddleExtent ) ) {
                  // Ball got past the paddle: reset the ball position and speed.
                  this.translateTo( [ 0, 0, 0 ] );
                  this.xSpeed = 2;
                  this.ySpeed = 5;
                  return true;
                } else {
                  // Ball hit the paddle: just bounce.
                  translation[ 0 ] = paddle.xPos;
                  this.xSpeed = -this.xSpeed;
                  return false;
                }
              };

  light:
    extends: http://vwf.example.com/light.vwf
    properties:
      distance: 2000
      translation: [400, -400, 900]
